## 第八章 指针

### 1. 指针变量的定义

#### 1.1 内存概述

在 32 位平台，每一个进程拥有 4G 的空间，系统为内存的每一个字节分配一个 32 位的地址编码（虚拟地址），这个编号称为地址。无论什么类型的地址都是存储单元的编号，在 32 位平台下都是 4 个字节，即任何类型的指针变量都是 4 个字节大小。

地址的编码格式决定了他能识别的范围，所以内存过大也没有，所以说当内存超过 8g 最好装个 64 位系统。

![1661182178937](cpp基础/1661182178937.png)





比如定义一个 int num；给 num 开辟四个字节的空间，每个字节都有对应的地址，但是要表现这个 num 的地址编号只能对变量 num 取地址，即变量首地址。

![1661184567135](cpp基础/1661184567135.png)

#### 1.2 地址和指针变量的关系

地址就是内存的地址编号。指针变量本质是变量，只是该变量保存的是内存地址的编号。

![1661267336380](cpp基础/1661267336380.png)

#### 1.3 指针变量的定义

**定义步骤：**

- *修饰指针变量p
- 保存谁的地址就先定义谁
- 从上往下整体替换

```c
//案例1：
定义一个指针变量 p 保存 int num 的地址： int *p;
1. *p
2. int num
3. int (*p) 括号可舍弃 int *p

定义一个指针变量 p 保存数组 int arr[5] 首地址： int (*p)[5];
1. *p
2. int arr[5]
3. int (*p)[5]

定义一个指针变量 p 保存函数的入口地址 int fun(int, int) 的地址： int (*p)(int, int);
1. *p
2. int fun(int, int)
3. int (*p)(int, int)

定义一个指针变量 p 保存结构体变量地址 struct stu lucy： struct stu *p;
1. *p
2. struct stu lucy
3. struct stu (*p) 括号可舍弃 struct stu *p
    
定义一个指针变量 p 保存指针变量 int *p 的地址： int **p;
1. *p
2. int *p
3. int *(*p) 括号可舍弃 int **p
```

**测试指针变量大小**

```c
//在32位平台任何类型的指针变量都是4字节，64位平台是8字节
cout << sizeof(char *) << endl;
cout << sizeof(short *) << endl;
cout << sizeof(int *) << endl;
cout << sizeof(long *) << endl;
cout << sizeof(float *) << endl;
cout << sizeof(double *) << endl;
cout << sizeof(int ********) << endl;
```

**指针变量和普通变量建立关系**

```c
int num = 10;
int *p;
p = &num;//普通变量和指针变量建立关系
```

![1661269885178](cpp基础/1661269885178.png)

#### 1.4 指针变量的初始化

指针变量如果不初始化立即操作会出现段错误，指针变量在操作之前必须指向合法的地址空间，如果没有指向合法的空间建议初始化为NULL，不要操作指向NULL的指针变量。

```c
int *p = NULL;//NULL是赋值给p  int *p; p = NULL;
```

```c
    int *p = NULL;
    cout << "11111" << endl;
    cout << p << endl;//指针变量的值：0000000000000000
    cout << "22222" << endl;
    cout << &p << endl;//指针变量的地址编号：000000515DCFFA48
    cout << "33333" << endl;
    cout << *p << endl;//指针变量的值没有指向的内存空间，即没有任何的内存空间的地址编号是0000000000000000。空指针段错误，下面不会执行
    cout << "44444" << endl;
```

将指针变量初始化为合法的地址：变量的地址、动态申请的地址、函数入口的地址...

```c
int num = 1;
int *p = &num;//定义并初始化
int *p1; p1 = &num;
int data = 2, *p2 = &data;//在一行上定义用都好分隔，类型在最左边修饰，p2是int类型指针，p2的值是data变量的地址编号
```

#### 1.5 指针变量的类型

指针变量自身的类型，将指针变量名抽取出来剩下的就是该指针变量自身的类型

```c
int *p;//p自身的类型为 int *
cout << typeid(p).name() << endl;
//32位平台输出：int *
//64位平台输出：int * __ptr64
```

指针变量自身的类型一般用于赋值语句的判断

```c
int num = 1;
int *p = &num;
//num 为 int 类型， &num 为 int * 类型 == 对变量名 取地址 整体类型加一个*
//p 为 int * 类型， *p 为 int 类型 == 对指针变量 取* 整体类型减一个*
//&和*相遇 从右往左 依次抵消 *&p = p
```

```c
//案例
int num = 10;
int *p = &num;
int **q = &p;
//下面成立
p = &num;
*p = num;
q = &p
*q = p = &num;
**q = *p = num;
//左边变量的值等于右边所有修饰符加变量名，如：int **q = &p; => q = &p
//对变量名取*规则如：p = &num => *p = *&num => &和*相遇抵消 => *p = num
```



### 2. 指针变量指向类型的作用



### 3. 数组元素的指针



